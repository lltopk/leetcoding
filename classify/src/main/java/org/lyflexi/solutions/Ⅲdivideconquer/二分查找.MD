大K问题会导致堆排序klogn超时, 就要用到二分查找来优化了

## 左闭右开
特点: 循环不变量, l左侧始终是小于目标值的元素, r右侧始终是大于目标值的元素, 因此最终l,r交会处就是解

以左闭右开区间[l,r)为例, 细节上程序需要注意以下几点
- right的初始值是n, 表示不包含n
- while的条件是left<right, 表示当left==right区间无效
- if(nums[mindex]<target)的处理是left = mindex+1, 表示左闭
- else处理是right = mindex, 表示右开

```java
    public int lowerBound(int[] nums, int target) {
      int n = nums.length;
      int left = 0;
      //左闭右开写法[l,r)
      int right = n;
      //当left == right就不存在区间了因此退出循环
      while(left<right){
        int mindex = left + ((right-left)>>1);
        if(nums[mindex]<target){
          left = mindex+1;
        }
        //else这里包含了nums[mindex]>target和nums[mindex]==target, 因此默认求的是左边界
        else{
          right = mindex;
        }
      }
      //没找到返回-1
      return (left == nums.length || target != nums[left])?-1:left;
    }
```
约定`[left,right)`而不是`[left,right]`的潜在好处是, 由于区间本身不包含right, 因此区间失效即循环退出的同时，恰好 left == right.

## 理解左边界L
自然排序的数组,
1. 如果target>nums[n-1], while循环退出后, l==n, 见LC439 
2. 如果target<nums[0], while循环退出后, l==0
3. 如果nums[0]<target<nums[n-1]且不等于数组元素, while循环退出后, l为刚好大于target的索引, 即小于target的最大索引是l-1

也就是说, 二分lowerBound(nums,x)默认求解的是 ≥x 的第一个元素的下标

## 通式排列组合
结合目标为重复元素的情况, 这样举例更通用, 如 `...a,x,x,x,b...`, 二分查找有如下查找需求:
- ①查找 x 的左边界(默认)	                    lowerBound(nums,x)
- ②查找 x 的左边界外最大值a下标	                lowerBound(nums,x)−1

上述①和②是相邻关系

- ③查找 x 的右边界	                            lowerBound(nums,x+1)−1
- ④查找 x 的右边界外最小值b下标(等价于查找≥x+1)	    lowerBound(nums,x+1)

上述③和④是相邻关系

### 重复元素求左界
非严格递增序列, 代表有重复元素的序列
```java
   private int getLBorder(int[] nums,int target){
        int n = nums.length;
        int left = 0;
        int lBorder = -1;
        //区间不变量
        int right = n;
        while(left<right){
            int mIndex = left + ((right-left)>>1);
            //重复元素求左边界, 当nums[mIndex]<=target继续移动右界
            if(nums[mIndex]>=target){
                right = mIndex;
                lBorder = mIndex;
            }else{
                left = mIndex+1;
            }
        }

        return lBorder;
    }
```
### 重复元素求右界
非严格递增序列, 代表有重复元素的序列
```java
    private int getRBorder(int[] nums,int target){
        int n = nums.length;
        int left = 0;
        //区间不变量
        int right = n;
        int rBoard = -1;
        while(left<right){
            int mIndex = left + ((right-left)>>1);
            //重复元素求右边界, 当nums[mIndex]<=target继续移动左界
            if(nums[mIndex]<=target){
                left = mIndex+1;
                rBoard = mIndex;
            }else {
                right = mIndex;
            }
        }
        return rBoard;
    }
```

## 找到满足条件的某值
有下面几种题, 题目并没有明确给出目标值, 只是说要找到一个满足条件的值

参见LC153(旋转排序数组),LC154(旋转排序重复数组), 这类题目我们的不等式对比的是数组右值
- 因此在迭代中必然会用到索引right本身

参见LC162(寻找峰值), LC540(重复数组中的单一元素), 这类题目我们的不等式对比的是中索引右值
- 因此在迭代中必然会用到索引midIndex+1

无论是上述索引right本身, 或是索引midIndex+1(有可能等于right本身), 都会造成数组越界问题, 因此必须初始化l,r指针[0,n-1), 这是有别于标准二分模板[0,n)的地方

请放心, [0,n-1)相较于[0,n)并不影响迭代过程中的切割点

## 映射转换二分
有些题给出的原数组本身是不符合二分的, 但可以通过题目要素凑二分
- 将原数组映射为新数组
- 确定新数组的比较关系

这类题目有LC1539(第 k 个缺失的正整数), LC274/LC275(H指数), LC2300(咒语和药水的成功对数), LC1498(满足条件的子序列数目), LC528(按权重随机选择), LC287(寻找重复数)

