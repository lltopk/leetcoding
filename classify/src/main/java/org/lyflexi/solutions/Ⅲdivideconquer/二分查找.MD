大K问题会导致堆排序klogn超时, 就要用到二分查找来优化了

## 左闭右开
对于二分查找来说, [l, r) 是所有可能答案的集合, 在循环开始前成立，并且在每一次循环迭代开始时都保持成立（不变的事实）, 这就是循环不变量

直到循环结束, l==r, 此时[l, r)为空区间, 最后我们只需要取l即可

程序的细节上需要注意以下几点
- right的初始值是n, 表示不包含n
- while的条件是`left<right`, 表示当`left==right`区间无效
- `if(nums[mindex]<target)`的处理是`left = mindex+1`, 表示左闭
- else处理是`right = mindex`, 表示右开

```java
    public int lowerBound(int[] nums, int target) {
      int n = nums.length;
      int left = 0;
      //左闭右开写法[l,r)
      int right = n;
      //当left == right就不存在区间了因此退出循环
      while(left<right){
        int mindex = left + ((right-left)>>1);
        if(nums[mindex]<target){
          left = mindex+1;
        }
        //else这里包含了nums[mindex]>target和nums[mindex]==target, 因此默认求的是左边界
        else{
          right = mindex;
        }
      }
      //没找到返回-1
      return (left == nums.length || target != nums[left])?-1:left;
    }
```
约定`[left,right)`而不是`[left,right]`的潜在好处是, 由于区间本身不包含right, 因此区间失效即循环退出的同时，恰好 `left == right`.

## 理解左边界L
**自然排序的数组, 二分lowerBound(nums,x)默认求解的是 ≥x 的第一个元素的下标**

如果数组元素唯一, 则l就是目标索引

如果数组元素有重复, 则l为左边界下标

但如果数组中不存在目标元素, 总共有三种查找失效情况, 分别是
1. 如果`target>nums[n-1]`, while循环退出后, `l==n`
2. 如果`target<nums[0]`, while循环退出后, `l==0 && nums[0]>target`
3. 如果`nums[0]<target<nums[n-1]`且不等于数组元素, while循环退出后, `nums[l]>target && nums[l-1]< target`

并且基于上述三种失效情况, 我们可以进一步利用最终的`nums[l]`做计算, 来解决复杂问题, 见LC1385, LC1818, LCP 08, 

上述三种失效情况可以推导为下面两种`松散`归纳(白马是马), 因为是`松散推导`所以并不等价但足够使用, 见LC33搜索旋转排序数组. 
1. `l==n`
2. `nums[l]!=target`

更准确全面的失效细节还是在上面三种情况


## 通式点位排列组合
结合目标为重复元素的情况, 这样举例更通用, 如 `...a,x,x,x,b...`, 二分查找有如下查找需求:
- ①查找 x 的左边界(默认`>=x`)	                    `lowerBound(nums,x)`
- ②查找 x 的左边界外最大值a下标(`<x`)                 `lowerBound(nums,x)−1`

上述①和②是相邻关系, 并且`<x` 和 `≥x` 互为补集，元素个数之和为 n

- ③查找 x 的右边界(`≤x`)	                        `lowerBound(nums,x+1)−1`
- ④查找 x 的右边界外最小值b下标(`>x`)	                `lowerBound(nums,x+1)`

上述③和④是相邻关系, 并且≤x 和 >x 互为补集，元素个数之和为 n

## 映射数组二分
有些题给出的原数组本身是不符合二分的, 但可以**预处理**原数组为新数组, 在新数组中进行二分, 达到logn

这类题目有
- LC1539(第 k 个缺失的正整数)
- LC274/LC275(H指数)
- LC1498(满足条件的子序列数目)
- LC528(按权重随机选择)
- LC287(寻找重复数)
- LC2080(区间内查询数字的频率)
- LC2389(和有限的最长子序列)
- LC1170(比较字符串最小字母出现频次)
- LC1146(快照数组)
- LC981(基于时间的键值存储 同 1146 题)
- LC911(在线选举)
- LC3296(移山所需的最少秒数)
- LC3639(变为活跃状态的最小时间)

## 二分答案
有的时候二分计算并不是一个简单的条件, 这个时候我们抽象出复杂的比较函数, 依然以lowerBound算法为例

1. compareInc: 即判断 `nums[mid] < target` 为true, 增加左指针
```java
public int lowerBound(int[] nums, int target){
    while(l<r){
        int mid = (l+r)>>1;
        //自定义二分比较
        if(compareInc(nums, mid, target)){
            l = mid +1;
        }else{
            r = mid;
        }
        return l;
    }
}

//compareInc
boolean compareInc(int[] nums, int mid , int target){
    return nums[mid]<target;
}
```

2. compareDesc: 即判断 `nums[mid] >= target` 为true, 减少右指针
```java
public int lowerBound(int[] nums, int target){
    while(l<r){
        int mid = (l+r)>>1;
        //自定义二分比较
        if(compareDesc(nums, mid, target)){
            r = mid;
        }else{
            l = mid + 1;
        }
        return l;
    }
}

//compareDesc
boolean compareDesc(int[] nums, int mid , int target){
    return nums[mid]>=target;
}
```

上面二者选其一即可, 这类题目有下面几个
- LC2300(咒语和药水的成功对数)
- LC33(搜索旋转排序数组)
- LC274(H指数)
- LC275(H指数Ⅱ)
- LC1283(使结果不超过阈值的最小除数)
- LC2187(完成旅途的最少时间)
- LC1011(在 D 天内送达包裹的能力)
- LC875(爱吃香蕉的珂珂)


## 越界处理
有的时候, 题目并没有给出目标值target, 此时需要自己建立比较关系, 而在比较过程中会用到`nums[mid+1]`或者`nums[r]`

无论`mid+1`或者`r`, 都有可能取n, 造成数组越界, 因此必须初始化l,r指针[0,n-1), 这是有别于标准二分模板[0,n)的地方

回过头来如何理解[0,n-1)而不是[0,n)呢? 其实我们可以从题目背景出发

`nums[mid+1]`越界问题:
- LC162(寻找峰值, 初始化[l,r): [0,n-1), 当二分失败, l==n-1, 恰好是峰值, 因为数组两侧隐藏两个-∞)
- LC658(找到 K 个最接近的元素, 初始化[l,r): [0,n-k), 当二分失败l==n-k, 恰好是窗口左边界)
- LC540(重复数组中的单一元素, 初始化[l,r): [0,n-1), 当二分失败, l==n-1, 恰好也是单一元素)

`nums[r]`越界问题
- LC153(寻找旋转排序数组中的最小值, 初始化[l,r): [0,n-1), 当二分失败, l==n-1, 恰好也是旋转点)
- LC154(寻找旋转排序数组中的最小值 II, 初始化[l,r): [0,n-1), 当二分失败, l==n-1, 恰好也是旋转点)

请放心, [0,n-1)相较于[0,n)并不影响迭代过程中的切割点
