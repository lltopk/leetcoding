大K问题会导致堆排序klogn超时, 就要用到二分查找来优化了

## 左闭右开
特点: 循环不变量, l左侧始终是小于目标值的元素, r右侧始终是大于目标值的元素, 因此最终l,r交会处就是解

以左闭右开区间`[l,r)`为例, 细节上程序需要注意以下几点
- right的初始值是n, 表示不包含n
- while的条件是`left<right`, 表示当`left==right`区间无效
- `if(nums[mindex]<target)`的处理是`left = mindex+1`, 表示左闭
- else处理是`right = mindex`, 表示右开

```java
    public int lowerBound(int[] nums, int target) {
      int n = nums.length;
      int left = 0;
      //左闭右开写法[l,r)
      int right = n;
      //当left == right就不存在区间了因此退出循环
      while(left<right){
        int mindex = left + ((right-left)>>1);
        if(nums[mindex]<target){
          left = mindex+1;
        }
        //else这里包含了nums[mindex]>target和nums[mindex]==target, 因此默认求的是左边界
        else{
          right = mindex;
        }
      }
      //没找到返回-1
      return (left == nums.length || target != nums[left])?-1:left;
    }
```
约定`[left,right)`而不是`[left,right]`的潜在好处是, 由于区间本身不包含right, 因此区间失效即循环退出的同时，恰好 `left == right`.

## 理解左边界L
**自然排序的数组, 二分lowerBound(nums,x)默认求解的是 ≥x 的第一个元素的下标**

如果数组元素唯一, 则l就是目标索引

如果数组元素有重复, 则l为左边界下标

但如果数组中不存在目标元素, 总共有三种查找失效情况, 分别是
1. 如果`target>nums[n-1]`, while循环退出后, `l==n`
2. 如果`target<nums[0]`, while循环退出后, `l==0 && nums[0]>target`
3. 如果`nums[0]<target<nums[n-1]`且不等于数组元素, while循环退出后, `nums[l]>target && nums[l-1]< target`

并且基于上述三种失效情况, 我们可以进一步利用最终的`nums[l]`做计算, 来解决复杂问题, 见LC1385, LC1818

## 通式点位排列组合
结合目标为重复元素的情况, 这样举例更通用, 如 `...a,x,x,x,b...`, 二分查找有如下查找需求:
- ①查找 x 的左边界(默认`>=x`)	                    `lowerBound(nums,x)`
- ②查找 x 的左边界外最大值a下标(`<x`即`≤(x-1)`)                 `lowerBound(nums,x)−1`

上述①和②是相邻关系, 并且`<x` 和 `≥x` 互为补集，元素个数之和为 n

- ③查找 x 的右边界(`≤x`)	                        `lowerBound(nums,x+1)−1`
- ④查找 x 的右边界外最小值b下标(`>x`即`≥(x+1)`)	                `lowerBound(nums,x+1)`

上述③和④是相邻关系, 并且≤x 和 >x 互为补集，元素个数之和为 n

## 映射二分
有些题给出的原数组本身是不符合二分的, 但可以将原数组映射为新数组, 在新数组中进行二分, 达到logn

这类题目有
- LC1539(第 k 个缺失的正整数)
- LC274/LC275(H指数)
- LC2300(咒语和药水的成功对数)
- LC1498(满足条件的子序列数目)
- LC528(按权重随机选择)
- LC287(寻找重复数)
- LC2080(区间内查询数字的频率)
- LC2389(和有限的最长子序列)
- LC1170(比较字符串最小字母出现频次)
- LC1146(快照数组)
- LC981(基于时间的键值存储 同 1146 题)

## 越界处理
有的时候, 题目并没有给出目标值target, 此时需要自己建立比较关系, 而在比较过程中会用到`nums[mid+1]`或者`nums[r]`

无论`mid+1`或者`r`, 都有可能取n, 造成数组越界, 因此必须初始化l,r指针[0,n-1), 这是有别于标准二分模板[0,n)的地方

回过头来如何理解[0,n-1)而不是[0,n)呢? 其实我们可以从题目背景出发

`nums[mid+1]`越界问题:
- LC162(寻找峰值, 初始化[l,r): [0,n-1), 当二分失败, l==n-1, 恰好是峰值, 因为数组两侧隐藏两个-∞)
- LC658(找到 K 个最接近的元素, 初始化[l,r): [0,n-k), 当二分失败l==n-k, 恰好是窗口左边界)
- LC540(重复数组中的单一元素, 初始化[l,r): [0,n-1), 当二分失败, l==n-1, 恰好也是单一元素)

`nums[r]`越界问题
- LC153(寻找旋转排序数组中的最小值, 初始化[l,r): [0,n-1), 当二分失败, l==n-1, 恰好也是旋转点)
- LC154(寻找旋转排序数组中的最小值 II, 初始化[l,r): [0,n-1), 当二分失败, l==n-1, 恰好也是旋转点)

请放心, [0,n-1)相较于[0,n)并不影响迭代过程中的切割点
