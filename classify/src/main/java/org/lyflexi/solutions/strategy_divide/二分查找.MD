大K问题会导致堆排序klogn超时, 就要用到二分查找来优化了

## 左闭右开
对于二分查找来说, l,r初始化为[start, end) 是所有可能答案的集合, 在循环开始前成立，并且在每一次循环迭代开始时都保持成立（不变的事实）, 这就是循环不变量

直到循环结束, l==r, 此时[l, r)为空区间, 最后我们只需要取l即可

程序的细节上需要注意以下几点
- right的初始值是n, 表示不包含n
- while的条件是`left<right`, 表示当`left==right`区间无效
- `if(nums[mindex]<target)`的处理是`left = mindex+1`, 表示左闭
- else处理是`right = mindex`, 表示右开

```java
    public int lowerBound(int[] nums, int target) {
      int n = nums.length;
      int left = 0;
      //左闭右开写法[l,r)
      int right = n;
      //当left == right就不存在区间了因此退出循环
      while(left<right){
        int mindex = left + ((right-left)>>1);
        if(nums[mindex]<target){
          left = mindex+1;
        }
        //else这里包含了nums[mindex]>target和nums[mindex]==target, 因此默认求的是左边界
        else{
          right = mindex;
        }
      }
      //没找到返回-1
      return (left == nums.length || target != nums[left])?-1:left;
    }
```
约定`[left,right)`而不是`[left,right]`的潜在好处是, 由于区间本身不包含right, 因此区间失效即循环退出的同时，恰好 `left == right`.

## 理解左边界L
**自然排序的数组, 二分lowerBound(nums,x)默认求解的是 ≥x 的第一个元素的下标**

如果数组元素唯一, 则l就是目标索引

如果数组元素有重复, 则l为左边界下标

_但如果数组中不存在目标元素, 总共有三种查找失效情况, 分别是_
1. 如果`target>nums[n-1]`, while循环退出后, `l==n`
2. 如果`target<nums[0]`, while循环退出后, `l==0 && nums[0]>target`
3. 如果`nums[0]<target<nums[n-1]`且不等于数组元素, while循环退出后, `nums[l]>target && nums[l-1]< target`

二分结束, 分类讨论上述三种失败情况, 来解决复杂问题, 见LC1385, LC1818, LCP 08, 

上述三种(白马)失效情况可以推导为下面两种`松散`归纳(马), 因为是`松散推导`所以并不等价但足够使用, 见LC33搜索旋转排序数组. 
1. `l==n`
2. `nums[l]!=target`

更准确全面的失效细节还是在上面三种情况


## 通式点位排列组合
结合目标为重复元素的情况, 这样举例更通用, 如 `...a,x,x,x,b...`, 二分查找有如下查找需求:
- ①查找 x 的左边界(默认`>=x`)	                    `lowerBound(nums,x)`
- ②查找 x 的左边界外最大值a下标(`<x`)                 `lowerBound(nums,x)−1`

上述①和②是相邻关系, 并且`<x` 和 `≥x` 互为补集，元素个数之和为 n

- ③查找 x 的右边界(`≤x`)	                        `lowerBound(nums,x+1)−1`
- ④查找 x 的右边界外最小值b下标(`>x`)	                `lowerBound(nums,x+1)`

上述③和④是相邻关系, 并且≤x 和 >x 互为补集，元素个数之和为 n

## 预处理数组
_有些题给出的原数组本身是不符合二分的, 但可以预处理原数组为新数组, 在新数组中进行二分, 达到logn_

这类场景题居多, 这类题目可以在构造函数中直接完成预处理
- LC1539 第 k 个缺失的正整数
- LC274 H指数Ⅰ
- LC275 H指数Ⅱ
- LC1498 满足条件的子序列数目
- LC528 按权重随机选择
- LC287 寻找重复数
- LC2080 区间内查询数字的频率
- LC2389 和有限的最长子序列
- LC1170 比较字符串最小字母出现频次
- LC1146 快照数组
- LC981 基于时间的键值存储 同 1146 题
- LC911 在线选举
- LC3639 变为活跃状态的最小时间

## 越界处理
_有的时候, 题目并没有给出目标值target, 此时需要自己来选取`nums[mid]`的被比较对象是谁_

对于左闭右开区间[l, r)的越界处理如下: 

`nums[mid]比较nums[mid+1]`越界问题: 随着持续的`l = mid + 1`, 并且被比较对象需要在新的二分点位`mid = (l+r)/2`上加`1`, 导致取得`nums[n]`越界, 因此必须初始化l,r指针`[start,n-1)`, 这是有别于标准二分模板`[start,end)`的地方
- LC162(寻找峰值, 初始化`[start,n-1)`, 当二分失败, l==n-1, 恰好是峰值, 因为数组两侧隐藏两个-∞)
- LC658(找到 K 个最接近的元素, 初始化`[start,n-k)`, 当二分失败l==n-k, 恰好是窗口左边界)
- LC540(重复数组中的单一元素, 初始化`[start,n-1)`, 当二分失败, l==n-1, 恰好也是单一元素)

`nums[mid]比较nums[r]`越界问题
- LC153(寻找旋转排序数组中的最小值, 初始化`[start,n-1)`, 当二分失败, l==n-1, 恰好也是旋转点)
- LC154(寻找旋转排序数组中的最小值 II, 初始化`[start,n-1)`, 当二分失败, l==n-1, 恰好也是旋转点)

上述我们习惯于选取`nums[mid+1]`作为被比较对象

~~如果你习惯于选取`nums[mid-1]`作为被比较对象也可以, 那么同理随着持续的`r = mid`, 被比较对象需要在新的二分点位`(l+r)/2`上减1, 导致取得`nums[-1]`越界, 此时注意必须初始化l,r指针`[1,n)`~~

特别的, 如果题目描述左端点不会是答案, 或者右端点不会是答案, 则不必考虑越界问题, 如LCR069(山脉数组的峰顶索引), 当然这种题太简单了


## 二分答案
_二分猜答案, 需要根据题意找到趋势递增的量(可以是时间等要素), 确定该量的上下界之后, 对该量进行二分_ 

**二分答案推荐开区间写法, 开区间写法最终返回的答案恰好就是给等号的指针, 无需考虑加一减一等细节**, 例如:
- 「求最小」和二分查找求「排序数组中某元素的第一个位置」是类似的，逻辑判别中的等号给了指针`r`, 最终答案就是`r`, 其左边是不满足要求的，右边则是满足要求的
- 「求最大」, 逻辑判别中的等号需要给指针`l`, 最终答案就是`l`, 其左边是满足要求的，右边是不满足要求的。

**强调, 二分答案法中「求最小」与「求最大」均与传统二分重复元素无关, 我们只是满足题意上逻辑上大小的「表述」, 二分答案序列本身是不可能重复的**

二分答案的计算往往不会是一个简单的条件, 我们可以抽象出复杂的比较函数(猜答案函数), 依然以lowerBound算法为例

_「二分答案求最小」模板_
checkInc: 即判断 `nums[mid] < target` 为true, 增加左指针
```java
public int lowerBound(int[] nums, int target){
    //二分答案开区间写法, while(`x √ x`)
    while(l + 1 < r){
        int mid = (l+r)>>1;
        //自定义二分比较
        if(checkInc(nums, mid, target)){
            l = mid;//开区间写法无需加1
        }else{
            r = mid;
        }
        //二分答案求最小, 最终答案返回的是给等号的指针r
        return r;
    }
}

//在checkInc函数中进行具体计算, 当计算结果逻辑小于target则增长左指针
// 逻辑小于的含义是我需要增长左指针, 不等价于数学关系上的computeIncheck(...) < target
boolean checkInc(int[] nums, int mid , int target){
    return computeIncheck(...) 逻辑小于 target;
}
```

这类题目有下面几个
- LC2300 咒语和药水的成功对数
- LC33 搜索旋转排序数组
- LC274 H指数
- LC275 H指数Ⅱ
- LC1283 使结果不超过阈值的最小除数
- LC2187 完成旅途的最少时间
- LC1011 在 D 天内送达包裹的能力
- LC875 爱吃香蕉的珂珂
- LC3639 变为活跃状态的最小时间
- LC475 供暖器(不太好想)
- LC3296 移山所需的最少秒数
- LC1870 准时到达的列车最小时速

上述我们习惯于拿`checkInc`函数用来提升下标, `return computeIncheck(...) 逻辑小于 target` 则 `l=mid` 反之 `r = mid`,

~~如果你习惯于拿`checkDes`函数来缩减下标, 那么同理`return computeIncheck(...) 逻辑大于等于 target` 则 `r = mid` 反之 `l=mid`. 只是注意`checkDes`函数逻辑正好与`checkInc`函数逻辑相反~~

_另外有些更为复杂的二分答案问题会在check的过程中需要标记数据或者分组统计或者存储巧妙的计算公式, 为了避免影响其他二分点的场景分布情况, 我们需要借助辅助数组int[] mark/group/last..._

```java
//对于原数组是字符串的情况, 也是需要借助辅助数组, 因为字符串API性能低下且有记忆负担
checkInc(int mid, int[] mark, int target){
    //每次check过程中记得初始化辅助数组, 避免干扰其他二分点的状态分布
    Arrays.fill(mark, -1);
    //...

    return computeIncheck() < target;
}
```

这类二分搭配辅助数组题目有以下: 
- LC3639 变为活跃状态的最小时间
- LC3048 标记所有下标的最早秒数 I
- LC2981 找出出现至少三次的最长特殊子字符串 I
- LC2982 找出出现至少三次的最长特殊子字符串 II


_「二分答案求最大」模板_

首先是等号放给`l`, 即checkInc为`return computeIncheck(...) 逻辑小于等于 target` 则 `l=mid` 反之 `r = mid`,

由于等号放给了`l`, 因此整个二分函数返回的是`l` , 而不是`r`, 二分答案求最大模板如下: 
```java
public int lowerBound(int[] nums, int target){
    while(l + 1 < r){
        int mid = (l+r)>>1;
        //自定义二分比较
        if(checkInc(nums, mid, target)){
            l = mid;
        }else{
            r = mid;
        }
        return l;
    }
}

//当计算结果逻辑小于等于target则增长左指针
// 逻辑小于等于的含义是我需要增长左指针, 不等价于数学关系上的computeIncheck(...) <= target
boolean checkInc(int[] nums, int mid , int target){
    return computeIncheck(...) 逻辑小于等于 target;
}
```

求最大的二分答案题目:
- LC2226 每个小孩最多能分到多少糖果 1646
- LC2981 找出出现至少三次的最长特殊子字符串 I
- LC2982 找出出现至少三次的最长特殊子字符串 II
- LC2576 求出最多标记下标
- LC1898 可移除字符的最大数目
- LC1802 有界数组中指定下标处的最大值
- LC1642 可以到达的最远建筑
- LC2861 最大合金数

