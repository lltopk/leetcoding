大K问题会导致堆排序klogn超时, 就要用到二分查找来优化了

## 左闭右开
对于二分查找来说, l,r初始化为[start, end) 是所有可能答案的集合, 在循环开始前成立，并且在每一次循环迭代开始时都保持成立（不变的事实）, 这就是循环不变量

直到循环结束, l==r, 此时[l, r)为空区间, 最后我们只需要取l即可

程序的细节上需要注意以下几点
- right的初始值是n, 表示不包含n
- while的条件是`left<right`, 表示当`left==right`区间无效
- `if(nums[mindex]<target)`的处理是`left = mindex+1`, 表示左闭
- else处理是`right = mindex`, 表示右开

```java
    public int lowerBound(int[] nums, int target) {
      int n = nums.length;
      int left = 0;
      //左闭右开写法[l,r)
      int right = n;
      //当left == right就不存在区间了因此退出循环
      while(left<right){
        int mindex = left + ((right-left)>>1);
        if(nums[mindex]<target){
          left = mindex+1;
        }
        //else这里包含了nums[mindex]>target和nums[mindex]==target, 因此默认求的是左边界
        else{
          right = mindex;
        }
      }
      //没找到返回-1
      return (left == nums.length || target != nums[left])?-1:left;
    }
```
约定`[left,right)`而不是`[left,right]`的潜在好处是, 由于区间本身不包含right, 因此区间失效即循环退出的同时，恰好 `left == right`.

## 理解左边界L
**自然排序的数组, 二分lowerBound(nums,x)默认求解的是 ≥x 的第一个元素的下标**

如果数组元素唯一, 则l就是目标索引

如果数组元素有重复, 则l为左边界下标

但如果数组中不存在目标元素, 总共有三种查找失效情况, 分别是
1. 如果`target>nums[n-1]`, while循环退出后, `l==n`
2. 如果`target<nums[0]`, while循环退出后, `l==0 && nums[0]>target`
3. 如果`nums[0]<target<nums[n-1]`且不等于数组元素, while循环退出后, `nums[l]>target && nums[l-1]< target`

二分结束, 分类讨论上述三种失败情况, 来解决复杂问题, 见LC1385, LC1818, LCP 08, 

上述三种(白马)失效情况可以推导为下面两种`松散`归纳(马), 因为是`松散推导`所以并不等价但足够使用, 见LC33搜索旋转排序数组. 
1. `l==n`
2. `nums[l]!=target`

更准确全面的失效细节还是在上面三种情况


## 通式点位排列组合
结合目标为重复元素的情况, 这样举例更通用, 如 `...a,x,x,x,b...`, 二分查找有如下查找需求:
- ①查找 x 的左边界(默认`>=x`)	                    `lowerBound(nums,x)`
- ②查找 x 的左边界外最大值a下标(`<x`)                 `lowerBound(nums,x)−1`

上述①和②是相邻关系, 并且`<x` 和 `≥x` 互为补集，元素个数之和为 n

- ③查找 x 的右边界(`≤x`)	                        `lowerBound(nums,x+1)−1`
- ④查找 x 的右边界外最小值b下标(`>x`)	                `lowerBound(nums,x+1)`

上述③和④是相邻关系, 并且≤x 和 >x 互为补集，元素个数之和为 n

## 预处理数组
有些题给出的原数组本身是不符合二分的, 但可以**预处理**原数组为新数组, 在新数组中进行二分, 达到logn

这类题目有
- LC1539(第 k 个缺失的正整数)
- LC274/LC275(H指数)
- LC1498(满足条件的子序列数目)
- LC528(按权重随机选择)
- LC287(寻找重复数)
- LC2080(区间内查询数字的频率)
- LC2389(和有限的最长子序列)
- LC1170(比较字符串最小字母出现频次)
- LC1146(快照数组)
- LC981(基于时间的键值存储 同 1146 题)
- LC911(在线选举)
- LC3639(变为活跃状态的最小时间)

## 二分答案
**二分猜答案, 需要根据题意找到趋势递增的量(可以是时间等要素)**, 确定该量的上下界之后, 对该量进行二分 

这时候二分计算往往不会是一个简单的条件, 我们抽象出复杂的比较函数(猜答案函数), 依然以lowerBound算法为例

checkInc: 即判断 `nums[mid] < target` 为true, 增加左指针
```java
public int lowerBound(int[] nums, int target){
    while(l<r){
        int mid = (l+r)>>1;
        //自定义二分比较
        if(checkInc(nums, mid, target)){
            l = mid +1;
        }else{
            r = mid;
        }
        return l;
    }
}

//在checkInc函数中进行具体计算, 当计算结果小于target则增长左指针
boolean checkInc(int[] nums, int mid , int target){
    return computeIncheck(...) < target;
}
```

这类题目有下面几个
- LC2300(咒语和药水的成功对数)
- LC33(搜索旋转排序数组)
- LC274(H指数)
- LC275(H指数Ⅱ)
- LC1283(使结果不超过阈值的最小除数)
- LC2187(完成旅途的最少时间)
- LC1011(在 D 天内送达包裹的能力)
- LC875(爱吃香蕉的珂珂)
- LC3639(变为活跃状态的最小时间)
- LC475(供暖器(不太好想))
- LC3296(移山所需的最少秒数)
- LC1870(准时到达的列车最小时速)

**上述我们习惯于拿`checkInc`函数用来提升下标**, `return computeIncheck(...) < target` 则 `l=mid+1` 反之 `r = mid`,

_如果你习惯于拿`checkDes`函数来缩减下标, 那么同理`return computeIncheck(...) >= target` 则 `r = mid` 反之 `l=mid+1`. 只是注意`checkDes`函数逻辑正好与`checkInc`函数逻辑相反_

另外有些更为复杂的**二分答案**问题会在check的过程中不得不"修改"原数组, 为了避免影响其他二分点的场景分布情况, 我们需要借助**辅助数组int[] mark/last**来标记原数组
```java
//对于原数组是字符串的情况, 最好也是借助辅助数组, 因为字符串API性能低下且有记忆负担
checkInc(int mid, int target){
    //每次check过程中记得初始化辅助数组, 避免干扰其他二分点的状态分布
    Arrays.fill(mark, -1);
    //...

    return computeIncheck() < target;
}
```

这类二分搭配辅助数组题目有以下: 
- LC3639(变为活跃状态的最小时间)
- LC3048(标记所有下标的最早秒数 I)


## 越界处理
有的时候, 题目并没有给出目标值target, 此时需要自己建立比较关系, 我们从题目背景出发, 在比较过程中会用到`nums[mid+1]`或者`nums[r]`

无论`mid+1`或者`r`, 都有可能取`nums[n]`, 造成数组越界, 因此必须初始化l,r指针`[start,n-1)`, 这是有别于标准二分模板`[start,end)`的地方

`nums[mid]比较nums[mid+1]`越界问题:
- LC162(寻找峰值, 初始化`[start,n-1)`, 当二分失败, l==n-1, 恰好是峰值, 因为数组两侧隐藏两个-∞)
- LC658(找到 K 个最接近的元素, 初始化`[start,n-k)`, 当二分失败l==n-k, 恰好是窗口左边界)
- LC540(重复数组中的单一元素, 初始化`[start,n-1)`, 当二分失败, l==n-1, 恰好也是单一元素)

`nums[mid]比较nums[r]`越界问题
- LC153(寻找旋转排序数组中的最小值, 初始化`[start,n-1)`, 当二分失败, l==n-1, 恰好也是旋转点)
- LC154(寻找旋转排序数组中的最小值 II, 初始化`[start,n-1)`, 当二分失败, l==n-1, 恰好也是旋转点)

**上述我们习惯于拿`nums[mid]`比较`右端点`或者`nums[mid+1]`**, _如果你习惯于拿`nums[mid]`比较`左端点`或者`nums[mid-1]`也可以, 那么同理在二分过程中会取到`nums[-1]`越界, 此时注意必须初始化l,r指针`[1,n)`_

特别的, 如果题目描述左端点不会是答案, 或者右端点不会是答案, 则不必考虑越界问题, 如LCR069(山脉数组的峰顶索引), 当然这种题太简单了
