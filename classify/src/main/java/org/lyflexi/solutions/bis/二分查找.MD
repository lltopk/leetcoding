大K问题会导致堆排序klogn超时, 就要用到二分查找来优化了

## 机灵的二分框架
区间不变量原则[left.right), 此时
- right的初始值是n, 不是n-1
- while的条件是left<right, 不是left<=right
- if(nums[mindex]>target)的处理是right = mindex, 不是right = mindex-1

```java
    public int search(int[] nums, int target) {
        Arrays.sort(nums);
        int n = nums.length;
        int left = 0;
        //区间不变量[l,r)
        int right = n;//①
        while(left<right){//②
            int mindex = left + ((right-left)>>1);
            if(nums[mindex]>target){
                right = mindex;//③
            }else if(nums[mindex]<target){
                left = mindex+1;
            }else {
                left = right = mindex;
                return left;
            }
        }
        return -1;//约定没找到target, 返回索引-1
    }
}
```
约定`[left,right)`而不是`[left,right]`的潜在好处是, 循环退出时，唯一可能的情况就是 left == right。 原因如下
- 每次循环:left 只会增加 (left = mid + 1)
- 每次循环:right 只会减少或保持 (right = mid)
  所以每次循环 left 只能移动到不超过 right。

### 找不到target
自然排序的数组,
- 如果target>nums[n-1], while循环结束时不会return, 最终l==n, 小于target的最大索引是n-1, 见LC439
- 如果nums[0]<target<nums[n-1]且不等于数组元素, 当循环结束时不会return, 小于target的最大索引同样是l-1
- 如果target<nums[0], while循环结束不会return, 虽然l==r==0但target!=nums[0], 最终l==0
```java
    private Integer findTarget(int[] colume, int target){
        int l = 0;
        int n = colume.length;
        int r = n;
        int midIndex = -1;
        while(l<r){
            midIndex = l+((r-l)>>1);
            if(colume[midIndex]>target){
                r = midIndex;
            }else if(colume[midIndex]<target){
                l = midIndex +1;
            }else{
                l = r = midIndex;
                return colume[l];
            }
        }
        //没有找到, 都比target小, 则l==n
        if(l==n){
            return null;
        }
        return colume[l]>target?colume[l]:null;
    }
```


### 重复元素求左界
非严格递增序列, 代表有重复元素的序列
```java
   private int getLBorder(int[] nums,int target){
        int n = nums.length;
        int left = 0;
        int lBorder = -1;
        //区间不变量
        int right = n;
        while(left<right){
            int mIndex = left + ((right-left)>>1);
            //重复元素求左边界, 当nums[mIndex]<=target继续移动右界
            if(nums[mIndex]>=target){
                right = mIndex;
                lBorder = mIndex;
            }else{
                left = mIndex+1;
            }
        }

        return lBorder;
    }
```
### 重复元素求右界
非严格递增序列, 代表有重复元素的序列
```java
    private int getRBorder(int[] nums,int target){
        int n = nums.length;
        int left = 0;
        //区间不变量
        int right = n;
        int rBoard = -1;
        while(left<right){
            int mIndex = left + ((right-left)>>1);
            //重复元素求右边界, 当nums[mIndex]<=target继续移动左界
            if(nums[mIndex]<=target){
                left = mIndex+1;
                rBoard = mIndex;
            }else {
                right = mIndex;
            }
        }
        return rBoard;
    }
```

## 特殊情况目标值不固定
参见LC153(旋转排序数组),LC154(旋转排序重复数组), LC162(寻找峰值), 目标值一直在变化, 这类题目我们选取数组右值 或 中索引右值为虚拟target,

为了避免右索引越界问题, 必须初始化right为n-1, 这是有别于标准二分模板[l,r)的地方