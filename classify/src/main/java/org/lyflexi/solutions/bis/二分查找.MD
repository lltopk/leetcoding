大K问题会导致堆排序klogn超时, 就要用到二分查找来优化了

## 机灵的二分框架
区间不变量原则[left.right), 此时
- right的初始值是n, 不是n-1
- while的条件是left<right, 不是left<=right
- if(nums[mindex]>target)的处理是right = mindex, 不是right = mindex-1

```java
    public int search(int[] nums, int target) {
        Arrays.sort(nums);
        int n = nums.length;
        int left = 0;
        //区间不变量[l,r)
        int right = n;//①
        while(left<right){//②
            int mindex = left + ((right-left)>>1);
            if(nums[mindex]>target){
                right = mindex;//③
            }else if(nums[mindex]<target){
                left = mindex+1;
            }else {
                left = right = mindex;
                return left;
            }
        }
        return -1;//约定没找到target, 返回索引-1
    }
```
约定`[left,right)`而不是`[left,right]`的潜在好处是, 循环退出时，唯一可能的情况就是 left == right。 原因如下
- 每次循环:left 只会增加 (left = mid + 1)
- 每次循环:right 只会减少或保持 (right = mid)
  所以每次循环 left 只能移动到不超过 right。

### 目标值不存在
自然排序的数组,
1. 如果target>nums[n-1], while循环结束时不会return, 最终l==n, 小于target的最大索引是n-1, 见LC439 
2. 如果target<nums[0], while循环结束不会return, 虽然l==r==0但target!=nums[0], 最终l==0
3. 如果nums[0]<target<nums[n-1]且不等于数组元素, 当循环结束时不会return, 小于target的最大索引同样是l-1
```java
    private Integer findTarget(int[] column, int target){
        int l = 0;
        int n = column.length;
        int r = n;
        int midIndex = -1;
        while(l<r){
            midIndex = l+((r-l)>>1);
            if(column[midIndex]>target){
                r = midIndex;
            }else if(column[midIndex]<target){
                l = midIndex +1;
            }else{
                l = r = midIndex;
                return column[l];
            }
        }
        //没有找到, 都比target小, 则l==n
        if(l==n){
            return null;
        }
        return column[l]>target?column[l]:null;
    }
```


### 重复元素求左界
非严格递增序列, 代表有重复元素的序列
```java
   private int getLBorder(int[] nums,int target){
        int n = nums.length;
        int left = 0;
        int lBorder = -1;
        //区间不变量
        int right = n;
        while(left<right){
            int mIndex = left + ((right-left)>>1);
            //重复元素求左边界, 当nums[mIndex]<=target继续移动右界
            if(nums[mIndex]>=target){
                right = mIndex;
                lBorder = mIndex;
            }else{
                left = mIndex+1;
            }
        }

        return lBorder;
    }
```
### 重复元素求右界
非严格递增序列, 代表有重复元素的序列
```java
    private int getRBorder(int[] nums,int target){
        int n = nums.length;
        int left = 0;
        //区间不变量
        int right = n;
        int rBoard = -1;
        while(left<right){
            int mIndex = left + ((right-left)>>1);
            //重复元素求右边界, 当nums[mIndex]<=target继续移动左界
            if(nums[mIndex]<=target){
                left = mIndex+1;
                rBoard = mIndex;
            }else {
                right = mIndex;
            }
        }
        return rBoard;
    }
```

## 目标值不固定
参见LC153(旋转排序数组),LC154(旋转排序重复数组), 这类题目我们选取数组右值为虚拟target,
- 这种题目在迭代中必然会用到索引right本身

参见LC162(寻找峰值), 目标值一直在变化,  这类题目我们选取中索引右值为虚拟target,
- 这种题目在迭代中必然会用到索引midIndex+1

无论是索引right本身, 或是索引midIndex+1(有可能等于right本身), 都会造成数组越界问题, 因此必须初始化l,r指针[0,n-1), 这是有别于标准二分模板[0,n)的地方

请放心, [0,n-1)相较于[0,n)并不影响迭代过程中的切割点

## 关系映射凑二分
有些题给出的原数组本身是不符合二分的, 但可以通过题目要素凑二分
- 将原数组映射为新数组
- 确定新数组的比较关系

这类题目有LC1539(第 k 个缺失的正整数), LC274/LC275(H指数)

