递归问题 `Recursion`

明白一个函数的作用并相信它能完成这个任务，千万不要跳进这个函数里面企图探究更多细节， 否则就会陷入无穷的细节无法自拔，人脑能压几个栈啊．

## 递归三要素
递归, 通过函数调用自身来解决问题，从实现角度来看，它包括三要素：
1. 终止条件
2. 递归调用（递），程序不断深入的调用自身，通常传入更小或更简化的参数，直至达到上述的终止条件
3. 返回结果（归），由递达到终止条件之后，程序开始由最深层次的递函数开始逐层返回（归），汇聚每一层的结果

如求1+2+3+...+n的和，见以下代码：
```java
public int recur(int n){
    //终止条件
    if (n==1){
        return 1;
    }
    //递归调用（递）
    int rec = recur(n-1);
    //返回结果（归）
    return n+rec;
}
```
## 注意事项
- 属于“自上而下”的解决问题，由大到小拆解问题递归三要素，终止条件、递归调用（子问题）、返回结果（归）
- 当递归函数有返回值，子递归调用必须return，请注意这有别于终止条件的返回
- 当递归函数无返回值，收集结果（归）应当在递归参数当中体现
- 禁止状态变量的自增自减++--或者v=v+n或者v=v-n，即使v不是引用变量。因为会导致本来修改后的状态变量值按理是要传递给下一层递归的，结果在传递之前你把上一层（当前层）的状态变量也给修改了。正确的传参姿势是v+n/v-n直接塞给递归函数
- 禁止定义局部变量，由于反复递归导致局部变量被反复初始化，最终局部变量将毫无意义

## 等价迭代
一般而言，递归与迭代可以相互转换，它们代表着完全不同的解决范式： 迭代算法如下
```java
public int recur(int n){
    int res = 0;
    if (n==0){
        return 0;
    }
    for (int i = 1; i <=n; i++) {
        res = res + i;
    }
    return res;
}
```

## 递归与分治
递归是一种编程技巧，一种解决问题的思维方式；

_分治算法很大程度上是基于递归的，用于解决更具体的问题．_

**要注意分治与后面学的二分无关, 分治强调治, 二分强调分**

比如归并排序, 传给它半个数组，那么处理完后这半个数组就已经被排好了．
```java
void merge_sort(一个数组) {
  if (可以很容易处理) return;
  merge_sort(左半个数组);
  merge_sort(右半个数组);
  merge(左半个数组, 右半个数组);
}
```
注意到，merge_sort 与二叉树的后序遍历模板极其相似．

因为分治算法的套路是 分解 -> 解决（触底）-> 合并（回溯），先左右分解，再处理合并，回溯就是在退栈，

最后 merge 实现上与两个有序链表的合并一致．

整体上相当于后序遍历．