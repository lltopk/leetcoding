递归问题 `Recursion`

明白一个函数的作用并相信它能完成这个任务，千万不要跳进这个函数里面企图探究更多细节， 否则就会陷入无穷的细节无法自拔，人脑能压几个栈啊．

## 递归三要素
递归, 通过函数调用自身来解决问题，从实现角度来看，它包括三要素：
1. 终止条件
2. 递归调用（递），程序不断深入的调用自身，通常传入更小或更简化的参数，直至达到上述的终止条件
3. 返回结果（归），由递达到终止条件之后，程序开始由最深层次的递函数开始逐层返回（归），汇聚每一层的结果

如求1+2+3+...+n的和，见以下代码：
```java
public int recur(int n){
    //终止条件
    if (n==1){
        return 1;
    }
    //递归调用（递）
    int rec = recur(n-1);
    //返回结果（归）
    return n+rec;
}
```
## 注意事项
- 属于“自上而下”的解决问题，由大到小拆解问题递归三要素，终止条件、递归调用（子问题）、返回结果（归）
- 当递归函数有返回值，子递归调用必须return，请注意这有别于终止条件的返回
- 当递归函数无返回值，收集结果（归）应当在递归参数当中体现
- 禁止状态变量的自增自减++--或者v=v+n或者v=v-n，即使v不是引用变量。因为会导致本来修改后的状态变量值按理是要传递给下一层递归的，结果在传递之前你把上一层（当前层）的状态变量也给修改了。正确的传参姿势是v+n/v-n直接塞给递归函数
- 禁止定义局部变量，由于反复递归导致局部变量被反复初始化，最终局部变量将毫无意义

## 等价迭代
一般而言，递归与迭代可以相互转换，它们代表着完全不同的解决范式： 迭代算法如下
```java
public int recur(int n){
    int res = 0;
    if (n==0){
        return 0;
    }
    for (int i = 1; i <=n; i++) {
        res = res + i;
    }
    return res;
}
```